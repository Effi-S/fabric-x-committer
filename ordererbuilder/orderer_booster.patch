diff --git a/orderer/common/ledger/factory.go b/orderer/common/ledger/factory.go
new file mode 100644
index 000000000..f48557393
--- /dev/null
+++ b/orderer/common/ledger/factory.go
@@ -0,0 +1,63 @@
+package ledger
+
+import (
+	"github.com/hyperledger/fabric/common/ledger/blockledger"
+	"os"
+	"path/filepath"
+	"sync"
+)
+
+// Factory retrieves or creates new ledgers by channelID
+type Factory struct {
+	once     sync.Once
+	Location string
+	lock     sync.Mutex
+	ledgers  map[string]*CheapLedger
+}
+
+// GetOrCreate gets an existing ledger (if it exists)
+// or creates it if it does not
+func (f *Factory) GetOrCreate(channelID string) (blockledger.ReadWriter, error) {
+	f.once.Do(func() {
+		f.ledgers = make(map[string]*CheapLedger)
+	})
+
+	f.lock.Lock()
+	defer f.lock.Unlock()
+
+	if ledger, exists := f.ledgers[channelID]; exists {
+		return ledger, nil
+	}
+
+	dir := filepath.Join(f.Location, channelID)
+	if err := os.MkdirAll(dir, 0755); err != nil {
+		return nil, err
+	}
+
+	ledger := NewCheapLedger(filepath.Join(dir, "ledger.dat"))
+	f.ledgers[channelID] = ledger
+	return ledger, nil
+}
+
+// Remove removes an existing ledger
+func (f *Factory) Remove(channelID string) error {
+	panic("not implemented")
+	return nil
+}
+
+// ChannelIDs returns the channel IDs the Factory is aware of
+func (f *Factory) ChannelIDs() []string {
+	f.lock.Lock()
+	defer f.lock.Unlock()
+
+	var res []string
+	for channel := range f.ledgers {
+		res = append(res, channel)
+	}
+	return res
+}
+
+// Close releases all resources acquired by the factory
+func (f *Factory) Close() {
+	panic("not implemented")
+}
diff --git a/orderer/common/ledger/ledger.go b/orderer/common/ledger/ledger.go
new file mode 100644
index 000000000..12f8e6305
--- /dev/null
+++ b/orderer/common/ledger/ledger.go
@@ -0,0 +1,296 @@
+package ledger
+
+import (
+	"context"
+	"encoding/binary"
+	"fmt"
+	"os"
+	"sync"
+	"sync/atomic"
+
+	"github.com/golang/protobuf/proto"
+	"github.com/hyperledger/fabric-protos-go/common"
+	"github.com/hyperledger/fabric-protos-go/orderer"
+	ab "github.com/hyperledger/fabric-protos-go/orderer"
+	"github.com/hyperledger/fabric/common/ledger/blockledger"
+	"github.com/hyperledger/fabric/protoutil"
+)
+
+var (
+	Ledgers []*CheapLedger
+)
+
+type CheapLedger struct {
+	file     *os.File
+	filePath string
+	nextSeq  uint64
+	lock     sync.Mutex
+	cond     sync.Cond
+	size     int64
+	index    sync.Map
+}
+
+func (cl *CheapLedger) Iterator(startPosition *orderer.SeekPosition) (blockledger.Iterator, uint64) {
+	var startingBlockNumber uint64
+	switch start := startPosition.Type.(type) {
+	case *ab.SeekPosition_Oldest:
+		startingBlockNumber = 0
+	case *ab.SeekPosition_Newest:
+		newestBlockNumber := cl.Height() - 1
+		startingBlockNumber = newestBlockNumber
+	case *ab.SeekPosition_Specified:
+		startingBlockNumber = start.Specified.Number
+		height := cl.Height()
+		if startingBlockNumber > height {
+			return &blockledger.NotFoundErrorIterator{}, 0
+		}
+	case *ab.SeekPosition_NextCommit:
+		startingBlockNumber = cl.Height()
+	default:
+		return &blockledger.NotFoundErrorIterator{}, 0
+	}
+
+	ctx, cancel := context.WithCancel(context.Background())
+
+	it := &Iterator{
+		cancel:   cancel,
+		doneChan: ctx.Done(),
+		entries:  cl.Read(startingBlockNumber, ctx),
+	}
+
+	return it, startingBlockNumber
+
+}
+
+type Iterator struct {
+	entries  <-chan Entry
+	doneChan <-chan struct{}
+	cancel   func()
+}
+
+func (it *Iterator) Next() (*common.Block, common.Status) {
+	select {
+	case <-it.doneChan:
+		return nil, common.Status_BAD_REQUEST
+	case rawBlock := <-it.entries:
+		block := &common.Block{}
+		if err := proto.Unmarshal(rawBlock.Data, block); err != nil {
+			return nil, common.Status_INTERNAL_SERVER_ERROR
+		}
+		return block, common.Status_SUCCESS
+	}
+}
+
+func (it *Iterator) Close() {
+	it.cancel()
+}
+
+func (cl *CheapLedger) RetrieveBlockByNumber(blockNumber uint64) (*common.Block, error) {
+	entry := cl.Load(blockNumber)
+	block := &common.Block{}
+	err := proto.Unmarshal(entry.Data, block)
+	return block, err
+}
+
+func (cl *CheapLedger) Append(block *common.Block) error {
+	return cl.Write(protoutil.MarshalOrPanic(block), block.Header.DataHash)
+}
+
+type Entry struct {
+	Data []byte
+	Id   []byte
+	Seq  uint64
+}
+
+func NewCheapLedger(filePath string) *CheapLedger {
+	cl := &CheapLedger{
+		filePath: filePath,
+	}
+	write, err := os.OpenFile(filePath, os.O_WRONLY|os.O_CREATE|os.O_APPEND, 0666)
+	if err != nil {
+		panic(err)
+	}
+	cl.cond = sync.Cond{L: &cl.lock}
+	cl.file = write
+
+	return cl
+}
+
+func (cl *CheapLedger) Height() uint64 {
+	return atomic.LoadUint64(&cl.nextSeq)
+}
+
+func (cl *CheapLedger) Load(seq uint64) Entry {
+	val, exists := cl.index.Load(seq)
+	if !exists {
+		panic(fmt.Sprintf("sequence %d is not found in index", seq))
+	}
+
+	pos := val.(int64)
+
+	f, err := os.Open(cl.filePath)
+	if err != nil {
+		panic(err)
+	}
+
+	defer f.Close()
+
+	_, err = f.Seek(pos, 0)
+	if err != nil {
+		panic(err)
+	}
+
+	prefix := make([]byte, 8+32+4)
+
+	if _, err := f.Read(prefix); err != nil {
+		panic(err)
+	}
+
+	actualSeq := binary.BigEndian.Uint64(prefix[:8])
+	if seq != actualSeq {
+		panic(fmt.Sprintf("requested sequence %d but actual sequence is %d", seq, actualSeq))
+	}
+
+	id := prefix[8 : 8+32]
+
+	length := binary.BigEndian.Uint32(prefix[8+32:])
+
+	b := make([]byte, length)
+	if _, err := f.Read(b); err != nil {
+		panic(err)
+	}
+
+	return Entry{Seq: seq, Id: id, Data: b}
+}
+
+func (cl *CheapLedger) Write(b []byte, id []byte) error {
+	if len(id) != 32 {
+		panic(fmt.Sprintf("id should be of size 32, but it's of size %d", len(id)))
+	}
+
+	length := make([]byte, 4)
+	binary.BigEndian.PutUint32(length, uint32(len(b)))
+	seqBuff := make([]byte, 8)
+	binary.BigEndian.PutUint64(seqBuff, cl.nextSeq)
+
+	seq := cl.nextSeq
+	size := cl.size
+
+	cl.lock.Lock()
+	defer cl.lock.Unlock()
+
+	atomic.AddUint64(&cl.nextSeq, 1)
+	atomic.AddInt64(&cl.size, int64(len(b))+4+8+32)
+
+	buff := make([]byte, len(id)+len(b)+len(length)+len(seqBuff))
+	copy(buff, seqBuff)
+	copy(buff[8:], id)
+	copy(buff[8+32:], length)
+	copy(buff[8+32+4:], b)
+
+	if _, err := cl.file.Write(buff); err != nil {
+		return err
+	}
+
+	cl.file.Sync()
+
+	cl.index.Store(seq, size)
+
+	cl.cond.Broadcast()
+
+	return nil
+}
+
+func (cl *CheapLedger) Read(startSeq uint64, ctx context.Context) <-chan Entry {
+	cl.lock.Lock()
+	oldSize := cl.size
+	cl.lock.Unlock()
+
+	f, err := os.Open(cl.filePath)
+	if err != nil {
+		panic(err)
+	}
+
+	var pos int64
+	val, exists := cl.index.Load(startSeq)
+	if exists {
+		pos = val.(int64)
+	} else {
+		pos = oldSize
+	}
+
+	_, err = f.Seek(pos, 0)
+	if err != nil {
+		panic(err)
+	}
+
+	c := make(chan Entry)
+
+	go func() {
+		defer f.Close()
+
+		for {
+
+			select {
+			case <-ctx.Done():
+				return
+			default:
+
+			}
+
+			cl.lock.Lock()
+			for atomic.LoadInt64(&cl.size) == pos {
+				cl.cond.Wait()
+			}
+			cl.lock.Unlock()
+
+			select {
+			case <-ctx.Done():
+				return
+			default:
+
+			}
+
+			newSize := atomic.LoadInt64(&cl.size)
+
+			remainingBytesToRead := newSize - pos
+
+			cl.readEntries(remainingBytesToRead, f, c, ctx)
+
+			pos = newSize
+		}
+	}()
+
+	return c
+}
+
+func (cl *CheapLedger) readEntries(remainingBytesToRead int64, f *os.File, c chan Entry, ctx context.Context) {
+	for remainingBytesToRead > 0 {
+
+		prefix := make([]byte, 8+32+4)
+
+		if _, err := f.Read(prefix); err != nil {
+			panic(err)
+		}
+
+		seq := binary.BigEndian.Uint64(prefix[:8])
+		id := prefix[8 : 8+32]
+
+		length := binary.BigEndian.Uint32(prefix[8+32:])
+
+		b := make([]byte, length)
+
+		if _, err := f.Read(b); err != nil {
+			panic(err)
+		}
+
+		select {
+		case c <- Entry{Seq: seq, Id: id, Data: b}:
+		case <-ctx.Done():
+			return
+		}
+
+		remainingBytesToRead -= int64(length)
+		remainingBytesToRead -= 44 // 8 + 4 + 32
+	}
+}
diff --git a/orderer/common/server/main.go b/orderer/common/server/main.go
index f5a07b761..45ec94449 100644
--- a/orderer/common/server/main.go
+++ b/orderer/common/server/main.go
@@ -10,6 +10,7 @@ import (
 	"bytes"
 	"context"
 	"fmt"
+	"github.com/hyperledger/fabric/orderer/common/ledger"
 	"io/ioutil"
 	"net"
 	"net/http"
@@ -114,11 +115,13 @@ func Main() {
 		ordererRootCAsByChain: make(map[string][][]byte),
 		clientRootCAs:         serverConfig.SecOpts.ClientRootCAs,
 	}
+	/*
+		lf, err := createLedgerFactory(conf, metricsProvider)
+		if err != nil {
+			logger.Panicf("Failed to create ledger factory: %v", err)
+		}*/
 
-	lf, err := createLedgerFactory(conf, metricsProvider)
-	if err != nil {
-		logger.Panicf("Failed to create ledger factory: %v", err)
-	}
+	lf := &ledger.Factory{Location: conf.FileLedger.Location}
 
 	var bootstrapBlock *cb.Block
 	switch conf.General.BootstrapMethod {
