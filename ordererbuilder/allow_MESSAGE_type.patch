diff --git a/orderer/common/multichannel/registrar.go b/orderer/common/multichannel/registrar.go
index 08c92cfb3..4c6373db1 100644
--- a/orderer/common/multichannel/registrar.go
+++ b/orderer/common/multichannel/registrar.go
@@ -444,16 +444,7 @@ func (r *Registrar) BroadcastChannelSupport(msg *cb.Envelope) (*cb.ChannelHeader
 		cs = sysChan
 	}
 
-	isConfig := false
-	switch cs.ClassifyMsg(chdr) {
-	case msgprocessor.ConfigUpdateMsg:
-		isConfig = true
-	case msgprocessor.ConfigMsg:
-		return chdr, false, nil, errors.New("message is of type that cannot be processed directly")
-	default:
-	}
-
-	return chdr, isConfig, cs, nil
+	return chdr, false, cs, nil
 }
 
 // GetConsensusChain retrieves the consensus.Chain of the channel, if it exists.
diff --git a/orderer/consensus/smartbft/chain.go b/orderer/consensus/smartbft/chain.go
index 21fe5ae0f..e0a97d238 100644
--- a/orderer/consensus/smartbft/chain.go
+++ b/orderer/consensus/smartbft/chain.go
@@ -286,16 +286,8 @@ func (c *BFTChain) submit(env *cb.Envelope, configSeq uint64) error {
 // If the configSeq advances, it is the responsibility of the consenter
 // to revalidate and potentially discard the message
 // The consenter may return an error, indicating the message was not accepted
-func (c *BFTChain) Order(env *cb.Envelope, configSeq uint64) error {
-	seq := c.support.Sequence()
-	if configSeq < seq {
-		c.Logger.Warnf("Normal message was validated against %d, although current config seq has advanced (%d)", configSeq, seq)
-		if _, err := c.support.ProcessNormalMsg(env); err != nil {
-			return errors.Errorf("bad normal message: %s", err)
-		}
-	}
-
-	return c.submit(env, configSeq)
+func (c *BFTChain) Order(env *cb.Envelope, _ uint64) error {
+	return c.submit(env, 0)
 }
 
 // Configure accepts a message which reconfigures the channel and will
diff --git a/orderer/consensus/smartbft/verifier.go b/orderer/consensus/smartbft/verifier.go
index 2b9fdfc4c..88e33b18c 100644
--- a/orderer/consensus/smartbft/verifier.go
+++ b/orderer/consensus/smartbft/verifier.go
@@ -10,7 +10,6 @@ import (
 	"bytes"
 	"encoding/base64"
 	"encoding/hex"
-	"fmt"
 	"sync"
 	"sync/atomic"
 
@@ -163,35 +162,6 @@ func (v *Verifier) verifyRequest(rawRequest []byte, noConfigAllowed bool) (types
 		return types.RequestInfo{}, err
 	}
 
-	err = v.AccessController.Evaluate([]*protoutil.SignedData{
-		{Identity: req.sigHdr.Creator, Data: req.envelope.Payload, Signature: req.envelope.Signature},
-	})
-
-	if err != nil {
-		return types.RequestInfo{}, errors.Wrap(err, "access denied")
-	}
-
-	if noConfigAllowed && req.chHdr.Type != int32(cb.HeaderType_ENDORSER_TRANSACTION) {
-		return types.RequestInfo{}, errors.Errorf("only endorser transactions can be sent with other transactions")
-	}
-
-	switch req.chHdr.Type {
-	case int32(cb.HeaderType_CONFIG):
-	case int32(cb.HeaderType_ORDERER_TRANSACTION):
-		return types.RequestInfo{}, fmt.Errorf("orderer transactions are not supported in v3")
-	case int32(cb.HeaderType_ENDORSER_TRANSACTION):
-	default:
-		return types.RequestInfo{}, errors.Errorf("transaction of type %s is not allowed to be included in blocks", cb.HeaderType_name[req.chHdr.Type])
-	}
-
-	if req.chHdr.Type == int32(cb.HeaderType_CONFIG) {
-		err := v.ConfigValidator.ValidateConfig(req.envelope)
-		if err != nil {
-			v.Logger.Errorf("Error verifying config update: %v", err)
-			return types.RequestInfo{}, err
-		}
-	}
-
 	return v.ReqInspector.requestIDFromSigHeader(req.sigHdr)
 }
 
