package loadgen

import (
	"math/rand"

	"github.com/google/uuid"
	"github.ibm.com/decentralized-trust-research/scalable-committer/utils/channel"
	"go.uber.org/ratelimit"
)

// Generator generates new T each time Next() is called.
type Generator[T any] interface {
	Next() T
}

// NextN returns the next N values from the generator.
func NextN[T any](g Generator[T], num int) []T {
	txs := make([]T, 0, num)
	for i := 0; i < num; i++ {
		txs = append(txs, g.Next())
	}
	return txs
}

// ChanGenerator pull values from a channel.
type ChanGenerator[T any] struct {
	Chan channel.Reader[T]
}

// Next yields a new value from the channel.
// If the channel is closed, a default value is returned.
func (g *ChanGenerator[T]) Next() T {
	if g.Chan == nil {
		return *new(T)
	}
	val, ok := g.Chan.Read()
	if !ok {
		g.Chan = nil
		return *new(T)
	}
	return val
}

// BatchChanGenerator pull batch of values from a channel and yield them one by one.
type BatchChanGenerator[T any] struct {
	Chan      channel.Reader[[]T]
	lastBatch []T
	index     int
}

// Next yields a new value from the channel.
// If the channel is closed, a default value is returned.
func (g *BatchChanGenerator[T]) Next() T {
	if g.Chan == nil {
		return *new(T)
	}
	if g.index >= len(g.lastBatch) {
		var ok bool
		g.lastBatch, ok = g.Chan.Read()
		g.index = 0
		if !ok {
			g.Chan = nil
			return *new(T)
		}
		if len(g.lastBatch) == 0 {
			return *new(T)
		}
	}
	next := g.lastBatch[g.index]
	g.index++
	return next
}

// FloatToIntGenerator wraps a float generator and produces integers.
type FloatToIntGenerator struct {
	FloatGen Generator[float64]
}

// Next yields a new integer.
func (g *FloatToIntGenerator) Next() int {
	return int(g.FloatGen.Next())
}

// FloatToPositiveIntGenerator wraps a float generator and produces positive int (>=1).
type FloatToPositiveIntGenerator struct {
	FloatGen Generator[float64]
}

// Next yields a new integer.
func (g *FloatToPositiveIntGenerator) Next() int {
	return Max(int(g.FloatGen.Next()), 1)
}

// FloatToBooleanGenerator wraps a float generator and produces boolean (true when >=1).
type FloatToBooleanGenerator struct {
	FloatGen Generator[float64]
}

// Next yields a new integer.
func (g *FloatToBooleanGenerator) Next() bool {
	return int(g.FloatGen.Next()) > 0
}

// ConstGenerator produces a constant value.
type ConstGenerator[T any] struct {
	Const T
}

// Next yields the constant value.
func (g *ConstGenerator[T]) Next() T {
	return g.Const
}

// ByteArrayGenerator generates a random byte array of Size.
type ByteArrayGenerator struct {
	Size uint32
	Rnd  *rand.Rand
}

// Next yields a byte array.
func (g *ByteArrayGenerator) Next() []byte {
	batch := make([]byte, g.Size)
	_, err := g.Rnd.Read(batch)
	Must(err)
	return batch
}

// NilByteArrayGenerator generates nil.
type NilByteArrayGenerator struct{}

// Next yields a nil byte array.
func (*NilByteArrayGenerator) Next() []byte {
	return nil
}

// MultiGenerator generates an array of size determined by Count, with items generated by Gen.
type MultiGenerator[T any] struct {
	Count Generator[int]
	Gen   Generator[T]
}

// Next yields an array of items.
func (g *MultiGenerator[T]) Next() []T {
	return GenerateArray[T](g.Gen, g.Count.Next())
}

// GenerateArray generates an array of items of the requested size given a generator.
func GenerateArray[T any](g Generator[T], size int) []T {
	arr := make([]T, size)
	for i := range arr {
		arr[i] = g.Next()
	}
	return arr
}

// UUIDGenerator generates UUIDs.
type UUIDGenerator struct {
	Rnd *rand.Rand
}

// Next yields a UUID.
func (g *UUIDGenerator) Next() string {
	uuidObj, err := uuid.NewRandomFromReader(g.Rnd)
	Must(err)
	return uuidObj.String()
}

// RateLimiterGenerator limits the generator's rate.
type RateLimiterGenerator[T any] struct {
	Generator[T]
	Limiter ratelimit.Limiter
}

// Next yields a value at the required rate.
func (g *RateLimiterGenerator[T]) Next() T {
	val := g.Generator.Next()
	g.Limiter.Take()
	return val
}
